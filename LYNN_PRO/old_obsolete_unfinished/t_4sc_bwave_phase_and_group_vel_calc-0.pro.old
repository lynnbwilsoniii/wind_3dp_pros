;+
;*****************************************************************************************
;
;  FUNCTION :   t_4sc_bwave_phase_and_group_vel_calc.pro
;  PURPOSE  :   This routine takes the TPLOT handles associated with spacecraft positions
;                 and magnetic fields, from at least 4 spacecraft, to calculate the
;                 phase and group speeds (and unit vectors) of the waves within the user
;                 defined time ranges from each spacecraft.  This requires that the user
;                 provide the bulk flow velocity of the plasma to determine rest frame
;                 parameters.
;
;  CALLED BY:   
;               NA
;
;  INCLUDES:
;               NA
;
;  CALLS:
;               is_a_number.pro
;               test_tplot_handle.pro
;               is_a_3_vector.pro
;               test_plot_axis_range.pro
;               t_4sc_bwave_group_vel_calc.pro
;               get_data.pro
;               t_get_struc_unix.pro
;               store_data.pro
;               lbw_calc_complex_phase_4sc.pro
;               unit_vec.pro
;               lbw_diff.pro
;               mag__vec.pro
;               str_element.pro
;               plot_positions.pro
;               extract_tags.pro
;               box.pro
;               specplot.pro
;
;  REQUIRES:    
;               1)  UMN Modified Wind/3DP IDL Libraries
;
;  INPUT:
;               TPN_POSI     :  [4]-Element [string] array defining set and valid TPLOT
;                                 handles associated with spacecraft positions all in
;                                 the same coordinate basis
;               TPN_MAGF     :  [4]-Element [string] array defining set and valid TPLOT
;                                 handles associated with magnetic field data all in
;                                 the same coordinate basis
;               TRAN_SE      :  [4,2]-Element [double] array defining the time stamps of
;                                 points of interest to use for calculating the normal
;                                 unit vector.
;
;  EXAMPLES:    
;               [calling sequence]
;               
;
;  KEYWORDS:    
;               PERTDT       :  Scalar [numeric] defining the delta-t for the perturbing
;                                 time stamps about the time of interest
;                                 [Default = 0.01]
;               VBULK        :  [3]-Element [numeric] array defining the plasma bulk
;                                 flow velocity to use to convert the spacecraft frame
;                                 group speed to the plasma rest frame speed [km/s]
;                                 [Default = [0,0,0]]
;               DELVB        :  [3]-Element [numeric] array defining the uncertainty in
;                                 VBULK [km/s]
;                                 [Default = [0,0,0]]
;               FRAN         :  [2]-Element [numeric] array defining the range of
;                                 frequencies to use to filter the data before applying
;                                 the cross-correlation algorithm
;                                 [Default = FALSE]
;               K_VEC        :  [4,3]-Element [numeric] array defining the wave unit
;                                 vector determined from minimum variance analysis
;                                 [Default = FALSE]
;               DKVEC        :  [4,3]-Element [numeric] array defining the uncertainty in
;                                 the wave unit vector determined from minimum variance
;                                 analysis
;                                 [Default = 10% of K_VEC]
;               NOMSSG       :  If set, routine will not inform user of elapsed
;                                 computational time [s]
;                                 [Default = FALSE]
;
;   CHANGED:  1)  Continued to write routine
;                                                                   [08/13/2021   v1.0.0]
;             2)  Continued to write routine
;                                                                   [09/09/2021   v1.0.0]
;
;   NOTES:      
;               1)  This routine uses LU decomposition
;                     A . X = B
;                       A_ijm = (∆r_ij)_m
;                       B_ijm = (t_i - t_j)_m
;                       X     = (g/|g|)/V_gr,sc
;               2)  ∆r . k = V_gr,sc ∆t
;                       V_gr,sc         = 1/|X|
;                       (k/|k|)         = X/|X|
;                       V_gr,sc         = V_gr + Vsw
;                       V_gr            = V_gr,sc - Vsw
;               3)  ICB  =  Input Coordinate Basis
;               4)  Coordinate Systems
;                     SPG    :  Spinning Probe Geometric
;                     SSL    :  Spinning Sun-Sensor L-Vector
;                     DSL    :  Despun Sun-L-VectorZ (THEMIS and MMS Mission)
;                     BCS    :  Body Coordinate System (MMS Mission)
;                     DBCS   :  despun-BCS (MMS Mission)
;                     SMPA   :  Spinning, Major Principal Axis (MMS Mission)
;                     DMPA   :  Despun, Major Principal Axis (MMS Mission)
;                     GEI    :  Geocentric Equatorial Inertial
;                     GEO    :  Geographic
;                     GSE    :  Geocentric Solar Ecliptic
;                     GSM    :  Geocentric Solar Magnetospheric
;                     ICB    :  Input Coordinate Basis (e.g., GSE)
;               5)  ***  Still working  ***
;
;  REFERENCES:  
;               1)  Paschmann, G. and P.W. Daly (1998), "Analysis Methods for Multi-
;                      Spacecraft Data," ISSI Scientific Report, Noordwijk,
;                      The Netherlands., Int. Space Sci. Inst.
;               2)  Harris, F.J. "On the Use of Windows for Harmonic Analysis with the
;                      Discrete Fourier Transform," Proc. IEEE Vol. 66, No. 1,
;                      pp. 51-83, (1978).
;               3)  Balikhin, M.A., et al., "Experimental determination of the dispersion
;                      of waves observed upstream of a quasi-perpendicular shock,"
;                      Geophys. Res. Lett. 24(7), pp. 787--790, doi:10.1029/97GL00671,
;                      1997.
;               4)  Balikhin, M.A., et al., "Determination of the dispersion of low
;                      frequency waves downstream of a quasiperpendicular collisionless
;                      shock," Ann. Geophys. 15(2), pp. 143--151,
;                      doi:10.1007/s005850050429, 1997.
;                      1997.
;               5)  Balikhin, M.A., et al., "Identification of low frequency waves in the
;                      vicinity of the terrestrial bow shock," Planet. Space Sci. 51(11),
;                      pp. 693--702, doi:10.1016/S0032-0633(03)00104-1, 2003.
;               6)  Walker, S.N., et al., "A comparison of wave mode identification
;                      techniques," Ann. Geophys. 22(8), pp. 3021--3032,
;                      doi:10.5194/angeo-22-3021-2004, 2004.
;
;   CREATED:  08/12/2021
;   CREATED BY:  Lynn B. Wilson III
;    LAST MODIFIED:  09/09/2021   v1.0.0
;    MODIFIED BY: Lynn B. Wilson III
;
;*****************************************************************************************
;-

FUNCTION t_4sc_bwave_phase_and_group_vel_calc,tpn_posi,tpn_magf,tran_se,PERTDT=pertdt,$
                                              VBULK=vbulk,DELVB=delvb,FRAN=fran,      $
                                              K_VEC=k_vec,DKVEC=dkvec,                $
                                              NOMSSG=nomssg

ex_start       = SYSTIME(1)
;;----------------------------------------------------------------------------------------
;;  Define some constants and dummy variables
;;----------------------------------------------------------------------------------------
f              = !VALUES.F_NAN
d              = !VALUES.D_NAN
;;  Define defaults
npert          = 33L                                   ;;  # of perturbing points about selected time
npmid          = 16L                                   ;;  Element of midpoint in perturbing array
perd           = DINDGEN(npert[0]) - npmid[0]          ;;  Array of perturbing elements
usearr         = LINDGEN(5) + (npmid[0] - 2L)          ;;  Array of perturbing elements to use in analysis
del            = [-1d0,-5d-1,0d0,5d-1,1d0]
nd             = N_ELEMENTS(del)
;;----------------------------------------------------------------------------------------
;;  Coordinates and vectors
;;----------------------------------------------------------------------------------------
;;  Define some default strings
coord_dsl      = 'dsl'
coord_gse      = 'gse'
coord_gsm      = 'gsm'
coord_bcs      = 'bcs'                    ;;  Body Coordinate System (of MMS spacecraft)
coord_dbcs     = 'dbcs'                   ;;  despun-BCS
coord_dmpa     = 'dmpa'                   ;;  Despun, Major Principal Axis (coordinate system)
coordj2000     = 'j2000'                  ;;  GEI/J2000
coord_mag      = 'mag'
vec_str        = ['x','y','z']
vec_col        = [250,150, 50]
fac_lab        = ['par','per','tot']
start_of_day_t = '00:00:00.000000000'
end___of_day_t = '23:59:59.999999999'
start_of_day   = '00:00:00.000000'
end___of_day   = '23:59:59.999999'
;;  Error messages
noinput_mssg   = 'No input was supplied...'
no_tpns_mssg   = 'Not enough valid TPLOT handles supplied...'
badinpt_mssg   = 'Incorrect input format was supplied:  TRAN_SE must be an [4,2]-element [double] array'
battpdt_mssg   = 'The TPLOT handles supplied did not contain data...'
;;----------------------------------------------------------------------------------------
;;  Check input
;;----------------------------------------------------------------------------------------
test           = ((N_PARAMS() LT 2) OR (SIZE(tpn_posi,/TYPE) NE 7) OR                 $
                  (SIZE(tpn_magf,/TYPE) NE 7) OR (is_a_number(tran_se,/NOMSSG) EQ 0))
IF (test[0]) THEN BEGIN
  MESSAGE,noinput_mssg[0],/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
testp          = test_tplot_handle(tpn_posi,TPNMS=tpnposi)
testm          = test_tplot_handle(tpn_magf,TPNMS=tpnmagf)
test           = testp[0] AND testm[0]
goodp          = WHERE(tpnposi NE '',gdp)
goodm          = WHERE(tpnmagf NE '',gdm)
IF (gdp[0] LT 4 OR gdm[0] LT 4 OR ~test[0]) THEN BEGIN
  MESSAGE,no_tpns_mssg[0],/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
sznd           = SIZE(tran_se,/N_DIMENSIONS)
szdd           = SIZE(tran_se,/DIMENSIONS)
test           = ((N_ELEMENTS(tran_se) MOD 4) NE 0) OR ((sznd[0] NE 2) AND (N_ELEMENTS(tran_se) NE 8))
IF (test[0]) THEN BEGIN
  MESSAGE,badinpt_mssg[0],/INFORMATIONAL,/CONTINUE
  RETURN,0b
ENDIF
;;  Define time ranges
IF (szdd[1] NE 2) THEN trans = TRANSPOSE(tran_se) ELSE trans = REFORM(tran_se,4,2)
;;----------------------------------------------------------------------------------------
;;  Check keywords
;;----------------------------------------------------------------------------------------
;;  Check PERTDT
IF (is_a_number(pertdt,/NOMSSG)) THEN pdt = ABS(1d0*pertdt[0]) ELSE pdt = 1d-2
;;  Define perturbing time array
pert           = perd*pdt[0]                             ;;  Converted to ∆t about t_j
;;  Check VBULK
test           = (is_a_3_vector(vbulk,V_OUT=vswo ,/NOMSSG) EQ 0)
IF (test[0]) THEN BEGIN
  vbulk_on = 0b
  delvb_on = 0b
  vswo     = REPLICATE(0d0,3L)
ENDIF ELSE BEGIN
  ;;  VBULK is on --> check if it's properly used
  vswo     = REFORM(vswo)
  vbulk_on = (TOTAL(FINITE(vswo)) EQ 3)
  IF (vbulk_on[0]) THEN BEGIN
    ;;  Check DELVB
    test   = (is_a_3_vector(delvb,V_OUT=dvsw ,/NOMSSG) EQ 0)
    IF (test[0]) THEN BEGIN
      delvb_on = 0b
    ENDIF ELSE BEGIN
      dvsw     = ABS(REFORM(dvsw))
      delvb_on = (TOTAL(FINITE(dvsw)) EQ 3)
    ENDELSE
  ENDIF ELSE delvb_on = 0b
ENDELSE
;;  Check FRAN
IF (test_plot_axis_range(fran,/NOMSSG)) THEN BEGIN
  frq_ran = 1d0*fran[SORT(fran)]
  filt_on = 1b
ENDIF ELSE BEGIN
  filt_on = 0b
  frq_ran = REPLICATE(d,2L)
ENDELSE
;;  Check K_VEC
test           = (is_a_3_vector(k_vec,V_OUT=kkvec,/NOMSSG) EQ 0)
IF (test[0]) THEN BEGIN
  k_vec_on = 0b
  dkvec_on = 0b
  kkvec    = REPLICATE(0d0,3L)
ENDIF ELSE BEGIN
  ;;  K_VEC is on --> check if it's properly used
  kkvec    = REFORM(kkvec)
  k_vec_on = (TOTAL(FINITE(kkvec)) MOD 3) EQ 0
  IF (k_vec_on[0]) THEN BEGIN
    ;;  Check DKVEC
    test   = (is_a_3_vector(dkvec,V_OUT=dkkvc,/NOMSSG) EQ 0)
    IF (test[0]) THEN BEGIN
      dkvec_on = 0b
    ENDIF ELSE BEGIN
      dkkvc    = ABS(REFORM(dkkvc))
      dkvec_on = (TOTAL(FINITE(dkkvc)) EQ 3)
    ENDELSE
  ENDIF ELSE dkvec_on = 0b
ENDELSE
;;----------------------------------------------------------------------------------------
;;  Calculate group speed, velocity, and time-lag indices
;;----------------------------------------------------------------------------------------
IF (filt_on[0]) THEN BEGIN
  ;;  Do filter data
  vg_struc       = t_4sc_bwave_group_vel_calc(tpnposi,tpnmagf,trans,PERTDT=pert,VBULK=vswo,$
                                              DELVB=dvsw,FRAN=frq_ran)
ENDIF ELSE BEGIN
  ;;  Do not filter data
  vg_struc       = t_4sc_bwave_group_vel_calc(tpnposi,tpnmagf,trans,PERTDT=pert,VBULK=vswo,$
                                              DELVB=dvsw)
ENDELSE
;;  Check output
IF (SIZE(vg_struc[0],/TYPE) NE 8) THEN STOP        ;;  Something went wrong --> Debug
;;----------------------------------------------------------------------------------------
;;  Define relevant parameters from group stuff
;;----------------------------------------------------------------------------------------
;;  Define proper shift value and corresponding array index (i.e., determines time lag)
jshft_arr      = [0L,vg_struc.CC_SHIFT_ARR]
scpos_arr      = vg_struc.SC_POSI
unix__arr      = vg_struc.UNIX
ix_mx_ij       = vg_struc.MAX_CC_IND             ;;  Index informing user of which B-field component has the best CC [12,13,14]
;;----------------------------------------------------------------------------------------
;;  Get TPLOT data
;;----------------------------------------------------------------------------------------
;;  Get Bo [nT, GSE]
get_data,tpnmagf[0],DATA=temp_magfv_1,DLIMIT=dlim_magfv_1,LIMIT=lim_magfv_1
get_data,tpnmagf[1],DATA=temp_magfv_2,DLIMIT=dlim_magfv_2,LIMIT=lim_magfv_2
get_data,tpnmagf[2],DATA=temp_magfv_3,DLIMIT=dlim_magfv_3,LIMIT=lim_magfv_3
get_data,tpnmagf[3],DATA=temp_magfv_4,DLIMIT=dlim_magfv_4,LIMIT=lim_magfv_4
;;  Define TPLOT data
bunix_1        = t_get_struc_unix(temp_magfv_1)
bunix_2        = t_get_struc_unix(temp_magfv_2)
bunix_3        = t_get_struc_unix(temp_magfv_3)
bunix_4        = t_get_struc_unix(temp_magfv_4)
bgsev_1        = temp_magfv_1.Y
bgsev_2        = temp_magfv_2.Y
bgsev_3        = temp_magfv_3.Y
bgsev_4        = temp_magfv_4.Y
;;  Shift Bo data and times then define new TPLOT handles
bunixs_1       = SHIFT(bunix_1,jshft_arr[0])
bunixs_2       = SHIFT(bunix_2,jshft_arr[1])
bunixs_3       = SHIFT(bunix_3,jshft_arr[2])
bunixs_4       = SHIFT(bunix_4,jshft_arr[3])
bgsevs_1       = SHIFT(bgsev_1,[jshft_arr[0],0L])
bgsevs_2       = SHIFT(bgsev_2,[jshft_arr[1],0L])
bgsevs_3       = SHIFT(bgsev_3,[jshft_arr[2],0L])
bgsevs_4       = SHIFT(bgsev_4,[jshft_arr[3],0L])
bstruct_1      = {X:bunixs_1,Y:bgsevs_1}
;;  Remove roll-over elements (i.e., those not in order)
IF (jshft_arr[1] GE 0) THEN BEGIN
  ;;  Positive shift --> remove starting elements
  lowupp         = ([jshft_arr[1],N_ELEMENTS(bunixs_2) - 1L]) > 0L
ENDIF ELSE BEGIN
  ;;  Negative shift --> remove ending elements
  lowupp         = [0L,N_ELEMENTS(bunixs_2) - 1L + jshft_arr[1]]
ENDELSE
bstruct_2      = {X:bunixs_2[lowupp[0]:lowupp[1]],Y:bgsevs_2[lowupp[0]:lowupp[1],*]}
IF (jshft_arr[2] GE 0) THEN BEGIN
  ;;  Positive shift --> remove starting elements
  lowupp         = [jshft_arr[2],N_ELEMENTS(bunixs_3) - 1L]
ENDIF ELSE BEGIN
  ;;  Negative shift --> remove ending elements
  lowupp         = [0L,N_ELEMENTS(bunixs_3) - 1L + jshft_arr[2]]
ENDELSE
bstruct_3      = {X:bunixs_3[lowupp[0]:lowupp[1]],Y:bgsevs_3[lowupp[0]:lowupp[1],*]}
IF (jshft_arr[3] GE 0) THEN BEGIN
  ;;  Positive shift --> remove starting elements
  lowupp         = [jshft_arr[2],N_ELEMENTS(bunixs_4) - 1L]
ENDIF ELSE BEGIN
  ;;  Negative shift --> remove ending elements
  lowupp         = [0L,N_ELEMENTS(bunixs_4) - 1L + jshft_arr[3]]
ENDELSE
bstruct_4      = {X:bunixs_4[lowupp[0]:lowupp[1]],Y:bgsevs_4[lowupp[0]:lowupp[1],*]}
;;  Define new TPLOT variables
;store_data,tpnmagf[0]+'_shifted',DATA=bstruct_1,DLIMIT=dlim_magfv_1,LIMIT=lim_magfv_1
;store_data,tpnmagf[1]+'_shifted',DATA=bstruct_2,DLIMIT=dlim_magfv_2,LIMIT=lim_magfv_2
;store_data,tpnmagf[2]+'_shifted',DATA=bstruct_3,DLIMIT=dlim_magfv_3,LIMIT=lim_magfv_3
;store_data,tpnmagf[3]+'_shifted',DATA=bstruct_4,DLIMIT=dlim_magfv_4,LIMIT=lim_magfv_4
store_data,tpnmagf[0]+'_shifted',DATA=temp_magfv_1,DLIMIT=dlim_magfv_1,LIMIT=lim_magfv_1
store_data,tpnmagf[1]+'_shifted',DATA=temp_magfv_2,DLIMIT=dlim_magfv_2,LIMIT=lim_magfv_2
store_data,tpnmagf[2]+'_shifted',DATA=temp_magfv_3,DLIMIT=dlim_magfv_3,LIMIT=lim_magfv_3
store_data,tpnmagf[3]+'_shifted',DATA=temp_magfv_4,DLIMIT=dlim_magfv_4,LIMIT=lim_magfv_4
;;----------------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------------
;;  Calculate complex phase
;;----------------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------------
new_tpnmagf    = tpnmagf+'_shifted'
cmplx_struc    = lbw_calc_complex_phase_4sc(new_tpnmagf,trans)
;;  Clean up no longer necessary TPLOT handles
store_data,DELETE=new_tpnmagf
;;----------------------------------------------------------------------------------------
;;  Define FFT frequencies [Hz]
;;----------------------------------------------------------------------------------------
fft_freq_1     = cmplx_struc.FFT_STRUCS.SC1.FFT_FREQ
fft_freq_2     = cmplx_struc.FFT_STRUCS.SC2.FFT_FREQ
fft_freq_3     = cmplx_struc.FFT_STRUCS.SC3.FFT_FREQ
fft_freq_4     = cmplx_struc.FFT_STRUCS.SC4.FFT_FREQ
nn             = N_ELEMENTS(fft_freq_1)
fft_freq_1     = fft_freq_1[0L:(nn[0]/2L)]
fft_freq_2     = fft_freq_2[0L:(nn[0]/2L)]
fft_freq_3     = fft_freq_3[0L:(nn[0]/2L)]
fft_freq_4     = fft_freq_4[0L:(nn[0]/2L)]
n1             = N_ELEMENTS(fft_freq_1)
ones           = REPLICATE(1d0,n1[0])
;fft_freq_1_2d  = fft_freq_1 # ones
;fft_freq_2_2d  = fft_freq_2 # ones
;fft_freq_3_2d  = fft_freq_3 # ones
;fft_freq_4_2d  = fft_freq_4 # ones
fft_freq_1_2d  = ones # fft_freq_1
fft_freq_2_2d  = ones # fft_freq_2
fft_freq_3_2d  = ones # fft_freq_3
fft_freq_4_2d  = ones # fft_freq_4
;;----------------------------------------------------------------------------------------
;;  Define FFT phase [rad] between any two signals:  phi_ij = ArcTan(Im[Xi],Re[Xj])
;;----------------------------------------------------------------------------------------
phibx12        = cmplx_struc.PHI_STRUCS.SC12[*,*,0]
phibx13        = cmplx_struc.PHI_STRUCS.SC13[*,*,0]
phibx14        = cmplx_struc.PHI_STRUCS.SC14[*,*,0]
phiby12        = cmplx_struc.PHI_STRUCS.SC12[*,*,1]
phiby13        = cmplx_struc.PHI_STRUCS.SC13[*,*,1]
phiby14        = cmplx_struc.PHI_STRUCS.SC14[*,*,1]
phibz12        = cmplx_struc.PHI_STRUCS.SC12[*,*,2]
phibz13        = cmplx_struc.PHI_STRUCS.SC13[*,*,2]
phibz14        = cmplx_struc.PHI_STRUCS.SC14[*,*,2]
nfft           = N_ELEMENTS(phibx12[*,0])
;;----------------------------------------------------------------------------------------
;;  Define FFT covariance between any two signals:
;;    C_ij = < Xi* Xj >_t
;;----------------------------------------------------------------------------------------
cvfbx12        = EXP(SMOOTH(ALOG(ABS(cmplx_struc.COV_STRUCS.SC12[*,*,0])),4L,/NAN,/EDGE_TRUNCATE))
cvfbx13        = EXP(SMOOTH(ALOG(ABS(cmplx_struc.COV_STRUCS.SC13[*,*,0])),4L,/NAN,/EDGE_TRUNCATE))
cvfbx14        = EXP(SMOOTH(ALOG(ABS(cmplx_struc.COV_STRUCS.SC14[*,*,0])),4L,/NAN,/EDGE_TRUNCATE))
cvfby12        = EXP(SMOOTH(ALOG(ABS(cmplx_struc.COV_STRUCS.SC12[*,*,1])),4L,/NAN,/EDGE_TRUNCATE))
cvfby13        = EXP(SMOOTH(ALOG(ABS(cmplx_struc.COV_STRUCS.SC13[*,*,1])),4L,/NAN,/EDGE_TRUNCATE))
cvfby14        = EXP(SMOOTH(ALOG(ABS(cmplx_struc.COV_STRUCS.SC14[*,*,1])),4L,/NAN,/EDGE_TRUNCATE))
cvfbz12        = EXP(SMOOTH(ALOG(ABS(cmplx_struc.COV_STRUCS.SC12[*,*,2])),4L,/NAN,/EDGE_TRUNCATE))
cvfbz13        = EXP(SMOOTH(ALOG(ABS(cmplx_struc.COV_STRUCS.SC13[*,*,2])),4L,/NAN,/EDGE_TRUNCATE))
cvfbz14        = EXP(SMOOTH(ALOG(ABS(cmplx_struc.COV_STRUCS.SC14[*,*,2])),4L,/NAN,/EDGE_TRUNCATE))
;;----------------------------------------------------------------------------------------
;;  Define theta_kV
;;----------------------------------------------------------------------------------------
IF (~k_vec_on[0]) THEN BEGIN
  ;;--------------------------------------------------------------------------------------
  ;;  No phase information can be derived without khat --> define dummy variables
  ;;--------------------------------------------------------------------------------------
  STOP
ENDIF ELSE BEGIN
  IF (vbulk_on[0] OR k_vec_on[0]) THEN BEGIN
    IF (vbulk_on[0] AND k_vec_on[0]) THEN BEGIN
      ;;----------------------------------------------------------------------------------
      ;;  Both are set
      ;;----------------------------------------------------------------------------------
      thkv_1         = REPLICATE(d,2L)
      thkv_2         = thkv_1
      thkv_3         = thkv_1
      thkv_4         = thkv_1
      ;;  Define preliminary values
      thkv_1[0]      = ACOS(TOTAL(unit_vec(kkvec[0,*],/NAN)*unit_vec(vswo,/NAN)))
      thkv_2[0]      = ACOS(TOTAL(unit_vec(kkvec[1,*],/NAN)*unit_vec(vswo,/NAN)))
      thkv_3[0]      = ACOS(TOTAL(unit_vec(kkvec[2,*],/NAN)*unit_vec(vswo,/NAN)))
      thkv_4[0]      = ACOS(TOTAL(unit_vec(kkvec[3,*],/NAN)*unit_vec(vswo,/NAN)))
      thkv_1[1]      = !DPI - thkv_1[0]
      thkv_2[1]      = !DPI - thkv_2[0]
      thkv_3[1]      = !DPI - thkv_3[0]
      thkv_4[1]      = !DPI - thkv_4[0]
      IF (delvb_on[0] OR dkvec_on[0]) THEN BEGIN
        IF (delvb_on[0] AND dkvec_on[0]) THEN BEGIN
          ;;------------------------------------------------------------------------------
          ;;  Both are set
          ;;------------------------------------------------------------------------------
        ENDIF ELSE BEGIN
          ;;------------------------------------------------------------------------------
          ;;  Only one is set
          ;;------------------------------------------------------------------------------
        ENDELSE
      ENDIF ELSE BEGIN
        ;;--------------------------------------------------------------------------------
        ;;  Neither uncertainty is set --> Don't change preliminary values
        ;;--------------------------------------------------------------------------------
      ENDELSE
    ENDIF ELSE BEGIN
      ;;----------------------------------------------------------------------------------
      ;;  Only one is set
      ;;----------------------------------------------------------------------------------
      IF (~k_vec_on[0]) THEN STOP
    ENDELSE
  ENDIF ELSE BEGIN
    ;;------------------------------------------------------------------------------------
    ;;  Assume the worst --> k is either parallel or anti-parallel to V
    ;;------------------------------------------------------------------------------------
    thkv_1         = [0d0,!DPI]
    thkv_2         = thkv_1
    thkv_3         = thkv_1
    thkv_4         = thkv_1
  ENDELSE
ENDELSE
;;  Make sure to sort
thkv_1         = thkv_1[SORT(thkv_1)]
thkv_2         = thkv_2[SORT(thkv_2)]
thkv_3         = thkv_3[SORT(thkv_3)]
thkv_4         = thkv_4[SORT(thkv_4)]
;;  Define Cos(theta_kV)
costhkv_1      = COS(thkv_1)
costhkv_2      = COS(thkv_2)
costhkv_3      = COS(thkv_3)
costhkv_4      = COS(thkv_4)
;;----------------------------------------------------------------------------------------
;;  Define differences
;;----------------------------------------------------------------------------------------
;;  ∆r_ij = r_i - r_j
dr_12_all      = MEDIAN(lbw_diff(REFORM(scpos_arr[*,0L,*]),REFORM(scpos_arr[*,1L,*]),/NAN),DIMENSION=1)
dr_13_all      = MEDIAN(lbw_diff(REFORM(scpos_arr[*,0L,*]),REFORM(scpos_arr[*,2L,*]),/NAN),DIMENSION=1)
dr_14_all      = MEDIAN(lbw_diff(REFORM(scpos_arr[*,0L,*]),REFORM(scpos_arr[*,3L,*]),/NAN),DIMENSION=1)
;;  ∆t_ij = t_i - t_j [s]
dt_12_all      = MEDIAN(lbw_diff(REFORM(unix__arr[*,0L]),REFORM(unix__arr[*,1L]),/NAN))
dt_13_all      = MEDIAN(lbw_diff(REFORM(unix__arr[*,0L]),REFORM(unix__arr[*,2L]),/NAN))
dt_14_all      = MEDIAN(lbw_diff(REFORM(unix__arr[*,0L]),REFORM(unix__arr[*,3L]),/NAN))
;;----------------------------------------------------------------------------------------
;;  Calculate theta_kr_ij = ArcCos(k . ∆r_ij)
;;----------------------------------------------------------------------------------------
costhkr_p1_12  = TOTAL(unit_vec(kkvec[0,*],/NAN)*unit_vec(dr_12_all,/NAN))
costhkr_p1_13  = TOTAL(unit_vec(kkvec[0,*],/NAN)*unit_vec(dr_13_all,/NAN))
costhkr_p1_14  = TOTAL(unit_vec(kkvec[0,*],/NAN)*unit_vec(dr_14_all,/NAN))
costhkr_m1_12  = TOTAL(-1d0*unit_vec(kkvec[0,*],/NAN)*unit_vec(dr_12_all,/NAN))
costhkr_m1_13  = TOTAL(-1d0*unit_vec(kkvec[0,*],/NAN)*unit_vec(dr_13_all,/NAN))
costhkr_m1_14  = TOTAL(-1d0*unit_vec(kkvec[0,*],/NAN)*unit_vec(dr_14_all,/NAN))
;;----------------------------------------------------------------------------------------
;;  Calculate denominator
;;    ∆r_ij Cos(the_krij) + |Vsw| ∆t Cos(the_kVij)
;;----------------------------------------------------------------------------------------
vbulk_mag      = (mag__vec(vswo,/NAN))[0]
term0_p1_12    = (mag__vec(dr_12_all,/NAN))[0]*costhkr_p1_12[0]
term0_p1_13    = (mag__vec(dr_13_all,/NAN))[0]*costhkr_p1_13[0]
term0_p1_14    = (mag__vec(dr_14_all,/NAN))[0]*costhkr_p1_14[0]
term0_m1_12    = (mag__vec(dr_12_all,/NAN))[0]*costhkr_m1_12[0]
term0_m1_13    = (mag__vec(dr_13_all,/NAN))[0]*costhkr_m1_13[0]
term0_m1_14    = (mag__vec(dr_14_all,/NAN))[0]*costhkr_m1_14[0]
term1_p1_12    = vbulk_mag[0]*dt_12_all[0]*costhkv_1[0L]
term1_p1_13    = vbulk_mag[0]*dt_13_all[0]*costhkv_1[0L]
term1_p1_14    = vbulk_mag[0]*dt_14_all[0]*costhkv_1[0L]
term1_m1_12    = vbulk_mag[0]*dt_12_all[0]*costhkv_1[1L]
term1_m1_13    = vbulk_mag[0]*dt_13_all[0]*costhkv_1[1L]
term1_m1_14    = vbulk_mag[0]*dt_14_all[0]*costhkv_1[1L]
denom_p1_12    = term0_p1_12 + term1_p1_12
denom_p1_13    = term0_p1_13 + term1_p1_13
denom_p1_14    = term0_p1_14 + term1_p1_14
denom_m1_12    = term0_m1_12 + term1_m1_12
denom_m1_13    = term0_m1_13 + term1_m1_13
denom_m1_14    = term0_m1_14 + term1_m1_14
;;----------------------------------------------------------------------------------------
;;  Calculate numerator
;;    phi_ij + wsc * ∆t_ij
;;----------------------------------------------------------------------------------------
;;  Initialize numerator
numer_x1_12    = phibx12; + fft_freq_1_2d*dt_12_all[0]
numer_x1_13    = phibx13; + fft_freq_1_2d*dt_13_all[0]
numer_x1_14    = phibx14; + fft_freq_1_2d*dt_14_all[0]
numer_y1_12    = phiby12; + fft_freq_1_2d*dt_12_all[0]
numer_y1_13    = phiby13; + fft_freq_1_2d*dt_13_all[0]
numer_y1_14    = phiby14; + fft_freq_1_2d*dt_14_all[0]
numer_z1_12    = phibz12; + fft_freq_1_2d*dt_12_all[0]
numer_z1_13    = phibz13; + fft_freq_1_2d*dt_13_all[0]
numer_z1_14    = phibz14; + fft_freq_1_2d*dt_14_all[0]
FOR ii=0L, n1[0] - 1L DO BEGIN
  numer_x1_12[ii,*] += (fft_freq_1*dt_12_all[0])
  numer_x1_13[ii,*] += (fft_freq_1*dt_13_all[0])
  numer_x1_14[ii,*] += (fft_freq_1*dt_14_all[0])
  numer_y1_12[ii,*] += (fft_freq_1*dt_12_all[0])
  numer_y1_13[ii,*] += (fft_freq_1*dt_13_all[0])
  numer_y1_14[ii,*] += (fft_freq_1*dt_14_all[0])
  numer_z1_12[ii,*] += (fft_freq_1*dt_12_all[0])
  numer_z1_13[ii,*] += (fft_freq_1*dt_13_all[0])
  numer_z1_14[ii,*] += (fft_freq_1*dt_14_all[0])
ENDFOR
;;----------------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------------
;;  Calculate |k| [km^(-1)]
;;    |k|_ij = [phi_ij + wsc * ∆t_ij]/[∆r_ij Cos(the_krij) + |Vsw| ∆t Cos(the_kVij)]
;;----------------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------------
;;----------------------------------------------------------------------------------------
;;  XYZ labels below correspond to component of field from which the spectral values were
;;    computed, not the component of the resultant wave vector.  The latter is determined
;;    by the projection onto the SC separation vector here, so currently the wave vector
;;    is defined in a non-orthogonal coordinate system and needs to be corrected (below).
kmag_xp1_12    = numer_x1_12/denom_p1_12[0]
kmag_xp1_13    = numer_x1_13/denom_p1_13[0]
kmag_xp1_14    = numer_x1_14/denom_p1_14[0]
kmag_yp1_12    = numer_y1_12/denom_p1_12[0]
kmag_yp1_13    = numer_y1_13/denom_p1_13[0]
kmag_yp1_14    = numer_y1_14/denom_p1_14[0]
kmag_zp1_12    = numer_z1_12/denom_p1_12[0]
kmag_zp1_13    = numer_z1_13/denom_p1_13[0]
kmag_zp1_14    = numer_z1_14/denom_p1_14[0]
kmag_xm1_12    = numer_x1_12/denom_m1_12[0]
kmag_xm1_13    = numer_x1_13/denom_m1_13[0]
kmag_xm1_14    = numer_x1_14/denom_m1_14[0]
kmag_ym1_12    = numer_y1_12/denom_m1_12[0]
kmag_ym1_13    = numer_y1_13/denom_m1_13[0]
kmag_ym1_14    = numer_y1_14/denom_m1_14[0]
kmag_zm1_12    = numer_z1_12/denom_m1_12[0]
kmag_zm1_13    = numer_z1_13/denom_m1_13[0]
kmag_zm1_14    = numer_z1_14/denom_m1_14[0]
;;----------------------------------------------------------------------------------------
;;  Sort |k| and C_ij for each frequency (only positive for now)
;;----------------------------------------------------------------------------------------
FOR ii=0L, n1[0] - 1L DO BEGIN
  ;;--------------------------------------------------------------------------------------
  ;;  Define sorting indices
  ;;--------------------------------------------------------------------------------------
  sp_px_12       = SORT(kmag_xp1_12[ii,*])
  sp_py_12       = SORT(kmag_yp1_12[ii,*])
  sp_pz_12       = SORT(kmag_zp1_12[ii,*])
  sp_px_13       = SORT(kmag_xp1_13[ii,*])
  sp_py_13       = SORT(kmag_yp1_13[ii,*])
  sp_pz_13       = SORT(kmag_zp1_13[ii,*])
  sp_px_14       = SORT(kmag_xp1_14[ii,*])
  sp_py_14       = SORT(kmag_yp1_14[ii,*])
  sp_pz_14       = SORT(kmag_zp1_14[ii,*])
  ;;--------------------------------------------------------------------------------------
  ;;  Redefine each accordingly
  ;;--------------------------------------------------------------------------------------
  ;;  Sort |k|
  kmag_xp1_12[ii,*] = kmag_xp1_12[ii,sp_px_12]
  kmag_yp1_12[ii,*] = kmag_yp1_12[ii,sp_py_12]
  kmag_zp1_12[ii,*] = kmag_zp1_12[ii,sp_pz_12]
  kmag_xp1_13[ii,*] = kmag_xp1_13[ii,sp_px_13]
  kmag_yp1_13[ii,*] = kmag_yp1_13[ii,sp_py_13]
  kmag_zp1_13[ii,*] = kmag_zp1_13[ii,sp_pz_13]
  kmag_xp1_14[ii,*] = kmag_xp1_14[ii,sp_px_14]
  kmag_yp1_14[ii,*] = kmag_yp1_14[ii,sp_py_14]
  kmag_zp1_14[ii,*] = kmag_zp1_14[ii,sp_pz_14]
  ;;  Sort C_ij
  cvfbx12[ii,*]     = cvfbx12[ii,sp_px_12]
  cvfby12[ii,*]     = cvfby12[ii,sp_py_12]
  cvfbz12[ii,*]     = cvfbz12[ii,sp_pz_12]
  cvfbx13[ii,*]     = cvfbx13[ii,sp_px_13]
  cvfby13[ii,*]     = cvfby13[ii,sp_py_13]
  cvfbz13[ii,*]     = cvfbz13[ii,sp_pz_13]
  cvfbx14[ii,*]     = cvfbx14[ii,sp_px_14]
  cvfby14[ii,*]     = cvfby14[ii,sp_py_14]
  cvfbz14[ii,*]     = cvfbz14[ii,sp_pz_14]
ENDFOR
;;  [*,ii]
;;  [sp_,ii]
;;  [ii,*]
;;  [ii,sp_]
;;----------------------------------------------------------------------------------------
;;  Combine into 3D arrays
;;----------------------------------------------------------------------------------------
;;  Combine |k| projections
kmag_ip1_12    = [[[kmag_xp1_12]],[[kmag_yp1_12]],[[kmag_zp1_12]]]          ;;  [N,N,{bx,by,bz}]-Element array from r12 for +k/|k|
kmag_ip1_13    = [[[kmag_xp1_13]],[[kmag_yp1_13]],[[kmag_zp1_13]]]          ;;  " " r13 " "
kmag_ip1_14    = [[[kmag_xp1_14]],[[kmag_yp1_14]],[[kmag_zp1_14]]]          ;;  " " r14 " "
kmag_im1_12    = [[[kmag_xm1_12]],[[kmag_ym1_12]],[[kmag_zm1_12]]]          ;;  " " r12 for -k/|k|
kmag_im1_13    = [[[kmag_xm1_13]],[[kmag_ym1_13]],[[kmag_zm1_13]]]          ;;  " " r13 " "
kmag_im1_14    = [[[kmag_xm1_14]],[[kmag_ym1_14]],[[kmag_zm1_14]]]          ;;  " " r14 " "
;;  Combine in k_ij vectors
ksep_ip1__x    = [[[kmag_xp1_12]],[[kmag_xp1_13]],[[kmag_xp1_14]]]          ;;  [N,N,{12,13,14}]-Element array from bx for +k/|k|
ksep_ip1__y    = [[[kmag_yp1_12]],[[kmag_yp1_13]],[[kmag_yp1_14]]]          ;;  " " by " "
ksep_ip1__z    = [[[kmag_zp1_12]],[[kmag_zp1_13]],[[kmag_zp1_14]]]          ;;  " " bz " "
ksep_im1__x    = [[[kmag_xm1_12]],[[kmag_xm1_13]],[[kmag_xm1_14]]]          ;;  " " bx for -k/|k|
ksep_im1__y    = [[[kmag_ym1_12]],[[kmag_ym1_13]],[[kmag_ym1_14]]]          ;;  " " by " "
ksep_im1__z    = [[[kmag_zm1_12]],[[kmag_zm1_13]],[[kmag_zm1_14]]]          ;;  " " bz " "
;;----------------------------------------------------------------------------------------
;;  Calculate k [km^(-1), GSE]
;;    Rotate from a non-orthogonal to an orthogonal coordinate system
;;      k_i = A_ij . k_ij
;;----------------------------------------------------------------------------------------
avec1          = unit_vec(dr_12_all,/NAN)
avec2          = unit_vec(dr_13_all,/NAN)
avec3          = unit_vec(dr_14_all,/NAN)
t_rot          = [avec1,avec2,avec3]
;t_rot          = TRANSPOSE([avec1,avec2,avec3])
a_rot          = LA_INVERT(t_rot,/DOUBLE,STATUS=status)
;a_rot          = TRANSPOSE(LA_INVERT(t_rot,/DOUBLE,STATUS=status))
IF (status[0] NE 0) THEN STOP       ;;  Non-invertable matrix --> Stop
kgse_pm1_bx    = REPLICATE(d,nfft[0],nfft[0],3L,2L)          ;;  [N,N,vec,+/-]
kgse_pm1_by    = kgse_pm1_bx
kgse_pm1_bz    = kgse_pm1_bx
ksep_pm1_bx    = kgse_pm1_bx                                 ;;  [N,N,{12,13,14},+/-]
ksep_pm1_by    = kgse_pm1_bx
ksep_pm1_bz    = kgse_pm1_bx
FOR j=0L, nfft[0] - 1L DO BEGIN
  ksep_px        = REFORM(ksep_ip1__x[j,*,*])
  ksep_py        = REFORM(ksep_ip1__y[j,*,*])
  ksep_pz        = REFORM(ksep_ip1__z[j,*,*])
  ksep_mx        = REFORM(ksep_im1__x[j,*,*])
  ksep_my        = REFORM(ksep_im1__y[j,*,*])
  ksep_mz        = REFORM(ksep_im1__z[j,*,*])
  ;;  Define SC separation basis variables
  ksep_pm1_bx[j,*,*,0L] = REFORM(ksep_px)
  ksep_pm1_by[j,*,*,0L] = REFORM(ksep_py)
  ksep_pm1_bz[j,*,*,0L] = REFORM(ksep_pz)
  ksep_pm1_bx[j,*,*,1L] = REFORM(ksep_mx)
  ksep_pm1_by[j,*,*,1L] = REFORM(ksep_my)
  ksep_pm1_bz[j,*,*,1L] = REFORM(ksep_mz)
  ;;  Rotate to GSE basis from non-orthogonal basis
  kgse_pm1_bx[j,*,*,0L] = REFORM(a_rot ## ksep_px)
  kgse_pm1_by[j,*,*,0L] = REFORM(a_rot ## ksep_py)
  kgse_pm1_bz[j,*,*,0L] = REFORM(a_rot ## ksep_pz)
  kgse_pm1_bx[j,*,*,1L] = REFORM(a_rot ## ksep_mx)
  kgse_pm1_by[j,*,*,1L] = REFORM(a_rot ## ksep_my)
  kgse_pm1_bz[j,*,*,1L] = REFORM(a_rot ## ksep_mz)
ENDFOR
;;----------------------------------------------------------------------------------------
;;  Find frequencies within observed range of interest
;;----------------------------------------------------------------------------------------
good_frq       = WHERE(fft_freq_1_2d GE frq_ran[0] AND fft_freq_1_2d LE frq_ran[1],gd_frq)
IF (gd_frq[0] GT 0) THEN BEGIN
  ;;  Look for peak correlations within frequency range
  mx_bx12        = MAX(cvfbx12[good_frq],/NAN,lx_bx12)
  mx_by12        = MAX(cvfby12[good_frq],/NAN,lx_by12)
  mx_bz12        = MAX(cvfbz12[good_frq],/NAN,lx_bz12)
  mx_bx13        = MAX(cvfbx13[good_frq],/NAN,lx_bx13)
  mx_by13        = MAX(cvfby13[good_frq],/NAN,lx_by13)
  mx_bz13        = MAX(cvfbz13[good_frq],/NAN,lx_bz13)
  mx_bx14        = MAX(cvfbx14[good_frq],/NAN,lx_bx14)
  mx_by14        = MAX(cvfby14[good_frq],/NAN,lx_by14)
  mx_bz14        = MAX(cvfbz14[good_frq],/NAN,lx_bz14)
  ;;  Define k-indices
  kind_bx12      = good_frq[lx_bx12[0]]
  kind_by12      = good_frq[lx_by12[0]]
  kind_bz12      = good_frq[lx_bz12[0]]
  kind_bx13      = good_frq[lx_bx13[0]]
  kind_by13      = good_frq[lx_by13[0]]
  kind_bz13      = good_frq[lx_bz13[0]]
  kind_bx14      = good_frq[lx_bx14[0]]
  kind_by14      = good_frq[lx_by14[0]]
  kind_bz14      = good_frq[lx_bz14[0]]
  ;;  Define k in projected basis
  kx_pm_12       = [(ksep_pm1_bx[*,*,0L,0L])[kind_bx12[0]],(ksep_pm1_bx[*,*,0L,1L])[kind_bx12[0]]]
  ky_pm_12       = [(ksep_pm1_by[*,*,0L,0L])[kind_by12[0]],(ksep_pm1_by[*,*,0L,1L])[kind_by12[0]]]
  kz_pm_12       = [(ksep_pm1_bz[*,*,0L,0L])[kind_bz12[0]],(ksep_pm1_bz[*,*,0L,1L])[kind_bz12[0]]]
  kx_pm_13       = [(ksep_pm1_bx[*,*,1L,0L])[kind_bx13[0]],(ksep_pm1_bx[*,*,1L,1L])[kind_bx13[0]]]
  ky_pm_13       = [(ksep_pm1_by[*,*,1L,0L])[kind_by13[0]],(ksep_pm1_by[*,*,1L,1L])[kind_by13[0]]]
  kz_pm_13       = [(ksep_pm1_bz[*,*,1L,0L])[kind_bz13[0]],(ksep_pm1_bz[*,*,1L,1L])[kind_bz13[0]]]
  kx_pm_14       = [(ksep_pm1_bx[*,*,2L,0L])[kind_bx14[0]],(ksep_pm1_bx[*,*,2L,1L])[kind_bx14[0]]]
  ky_pm_14       = [(ksep_pm1_by[*,*,2L,0L])[kind_by14[0]],(ksep_pm1_by[*,*,2L,1L])[kind_by14[0]]]
  kz_pm_14       = [(ksep_pm1_bz[*,*,2L,0L])[kind_bz14[0]],(ksep_pm1_bz[*,*,2L,1L])[kind_bz14[0]]]
  kxyz_pm_bx     = REPLICATE(d,3L,2L)        ;;  From Bx covariance
  kxyz_pm_by     = REPLICATE(d,3L,2L)        ;;  From By covariance
  kxyz_pm_bz     = REPLICATE(d,3L,2L)        ;;  From Bz covariance
  FOR i=0L, 1L DO BEGIN
    kxyz_pm_bx[*,i] = [kx_pm_12[i],kx_pm_13[i],kx_pm_14[i]]
    kxyz_pm_by[*,i] = [ky_pm_12[i],ky_pm_13[i],ky_pm_14[i]]
    kxyz_pm_bz[*,i] = [kz_pm_12[i],kz_pm_13[i],kz_pm_14[i]]
  ENDFOR
  ;;  Define k in GSE basis
  kgse_pm_bx     = REPLICATE(d,3L,2L)        ;;  From Bx covariance
  kgse_pm_by     = REPLICATE(d,3L,2L)        ;;  From By covariance
  kgse_pm_bz     = REPLICATE(d,3L,2L)        ;;  From Bz covariance
  FOR i=0L, 1L DO BEGIN
    kgse_pm_bx[*,i] = REFORM(a_rot ## kxyz_pm_bx[*,i])
    kgse_pm_by[*,i] = REFORM(a_rot ## kxyz_pm_by[*,i])
    kgse_pm_bz[*,i] = REFORM(a_rot ## kxyz_pm_bz[*,i])
  ENDFOR
  
  
  
ENDIF ELSE BEGIN
  ;;  Something is wrong --> Debug
  STOP
ENDELSE
;;----------------------------------------------------------------------------------------
;;  Set up plotting stuff
;;----------------------------------------------------------------------------------------
STOP
;;  Open plot window
WINDOW,1,XSIZE=1024L,YSIZE=1260
;;  Setup plot limits
xran           = [-0.1d0,5d0]
yran           = [-1,1]*3d-1
zran           = [1d-3,2d0]
lims           = {XRANGE:xran,YRANGE:yran,ZRANGE:zran,ZTICKS:4L,XLOG:0,YLOG:0,ZLOG:1,$
                  XTITLE:'frequency [Hz, SCF]',YTITLE:'|k_r12| [km^(-1)]',           $
                  ZTITLE:'< Xi* Xj >_t [nT^2 Hz^(-1)]',XSTYLE:1,YSTYLE:1,ZSTYLE:1}
def_opts       = {YMARGIN:[4.,2.],XMARGIN:[12.,15.],POSITION:FLTARR(4),TITLE:'', $
                  YTITLE:'',XTITLE:'',XRANGE:DBLARR(2),VERSION:3,                $
                  WINDOW:-1, WSHOW:0,XSTYLE:1,CHARSIZE:2e0,NOERASE:0,            $
                  OVERPLOT:0,SPEC:1,NO_INTERP:0,X_NO_INTERP:0,Y_NO_INTERP:0,     $
                  YGAP:2e0                                                       }
str_element,def_opts,'YGAP',VALUE=ygap
str_element,def_opts,'CHARSIZE',VALUE=chsize
nvlabs            = [0.,0.,0.,1.,0.]
nvl               = N_ELEMENTS(var_label) + nvlabs[def_opts.VERSION]
def_opts.YMARGIN += [nvl,0.]
!P.MULTI       = [0,1,3]
sizes          = REPLICATE(2.,3)
pos            = plot_positions(YSIZES=sizes,OPTIONS=def_opts,YGAP=ygap)
extract_tags,def_opts,lims
init_opts        = def_opts
init_opts.XSTYLE = 5
;;  erase old window if necessary
IF (init_opts.NOERASE EQ 0) THEN ERASE
init_opts.NOERASE = 1
str_element,init_opts,'YSTYLE',5,/ADD_REPLACE
;;  Plot an empty axes-less box for defining window positions etc.
box,init_opts
def_opts.NOERASE  = 0
def_opts.POSITION = pos[*,0]
newlim            = def_opts
newlm1            = newlim
newlm2            = newlim
newlm1.POSITION   = pos[*,1]
newlm2.POSITION   = pos[*,2]
str_element,newlm1,'YTITLE','|k_r13| [km^(-1)]',/ADD_REPLACE
str_element,newlm2,'YTITLE','|k_r14| [km^(-1)]',/ADD_REPLACE
;;  Define data and plot
xdat           = fft_freq_1
IF (ix_mx_ij[0] EQ 0) THEN ydat = kmag_xp1_12 ELSE IF (ix_mx_ij[0] EQ 1) THEN ydat = kmag_yp1_12 ELSE ydat = kmag_zp1_12
IF (ix_mx_ij[1] EQ 0) THEN ydt2 = kmag_xp1_13 ELSE IF (ix_mx_ij[1] EQ 1) THEN ydt2 = kmag_yp1_13 ELSE ydt2 = kmag_zp1_13
IF (ix_mx_ij[2] EQ 0) THEN ydt3 = kmag_xp1_14 ELSE IF (ix_mx_ij[2] EQ 1) THEN ydt3 = kmag_yp1_14 ELSE ydt3 = kmag_zp1_14
IF (ix_mx_ij[0] EQ 0) THEN zdat = cvfbx12 ELSE IF (ix_mx_ij[0] EQ 1) THEN zdat = cvfby12 ELSE zdat = cvfbz12
IF (ix_mx_ij[1] EQ 0) THEN zdt2 = cvfbx13 ELSE IF (ix_mx_ij[1] EQ 1) THEN zdt2 = cvfby13 ELSE zdt2 = cvfbz13
IF (ix_mx_ij[2] EQ 0) THEN zdt3 = cvfbx14 ELSE IF (ix_mx_ij[2] EQ 1) THEN zdt3 = cvfby14 ELSE zdt3 = cvfbz14
gdata          = {X:xdat,Y:zdat,V:ydat}
gdat2          = {X:xdat,Y:zdt2,V:ydt2}
gdat3          = {X:xdat,Y:zdt3,V:ydt3}
;;  Find maximum
gind_f         = WHERE(fft_freq_1 GE frq_ran[0] AND fft_freq_1 LE frq_ran[1],gd_f)
PRINT, MAX(zdat[gind_f,*],/NAN,lz1), MAX(zdt2[gind_f,*],/NAN,lz2), MAX(zdt3[gind_f,*],/NAN,lz3)
;PRINT, MAX(zdat[*,gind_f],/NAN,lz1), MAX(zdt2[*,gind_f],/NAN,lz2), MAX(zdt3[*,gind_f],/NAN,lz3)
PRINT, lz1[0], lz2[0], lz3[0]

gind_1         = ARRAY_INDICES(zdat[gind_f,*],lz1[0])
gind_2         = ARRAY_INDICES(zdt2[gind_f,*],lz2[0])
gind_3         = ARRAY_INDICES(zdt3[gind_f,*],lz3[0])
yind_1         = [gind_f[gind_1[0]],gind_1[1]]
yind_2         = [gind_f[gind_2[0]],gind_2[1]]
yind_3         = [gind_f[gind_3[0]],gind_3[1]]
;gind_1         = ARRAY_INDICES(zdat[*,gind_f],lz1[0])
;gind_2         = ARRAY_INDICES(zdt2[*,gind_f],lz2[0])
;gind_3         = ARRAY_INDICES(zdt3[*,gind_f],lz3[0])
;yind_1         = [gind_1[0],gind_f[gind_1[1]]]
;yind_2         = [gind_2[0],gind_f[gind_2[1]]]
;yind_3         = [gind_3[0],gind_f[gind_3[1]]]
kmax_12        = ydat[yind_1[0],yind_1[1]]
kmax_13        = ydt2[yind_2[0],yind_2[1]]
kmax_14        = ydt3[yind_3[0],yind_3[1]]
PRINT, kmax_12[0], kmax_13[0], kmax_14[0]
PRINT, REFORM(a_rot ## [kmax_12[0], kmax_13[0], kmax_14[0]])
PRINT, mag__vec(REFORM(a_rot ## [kmax_12[0], kmax_13[0], kmax_14[0]]))

;;  Plot
WSET,1
WSHOW,1
!P.MULTI       = [0,1,3]
lbw_specplot,DATA=gdata,LIMITS=newlim,NO_INTERP=0,X_NO_INTERP=0,Y_NO_INTERP=0
  OPLOT,[frq_ran[0],frq_ran[0]],yran,LINESTYLE=0,THICK=2
  OPLOT,[frq_ran[1],frq_ran[1]],yran,LINESTYLE=0,THICK=2
  OPLOT,[frq_ran[0],frq_ran[1]],[kmax_12[0],kmax_12[0]],PSYM=4,THICK=2,SYMSIZE=2
lbw_specplot,DATA=gdat2,LIMITS=newlm1,NO_INTERP=0,X_NO_INTERP=0,Y_NO_INTERP=0
  OPLOT,[frq_ran[0],frq_ran[0]],yran,LINESTYLE=0,THICK=2
  OPLOT,[frq_ran[1],frq_ran[1]],yran,LINESTYLE=0,THICK=2
  OPLOT,[frq_ran[0],frq_ran[1]],[kmax_13[0],kmax_13[0]],PSYM=4,THICK=2,SYMSIZE=2
lbw_specplot,DATA=gdat3,LIMITS=newlm2,NO_INTERP=0,X_NO_INTERP=0,Y_NO_INTERP=0
  OPLOT,[frq_ran[0],frq_ran[0]],yran,LINESTYLE=0,THICK=2
  OPLOT,[frq_ran[1],frq_ran[1]],yran,LINESTYLE=0,THICK=2
  OPLOT,[frq_ran[0],frq_ran[1]],[kmax_14[0],kmax_14[0]],PSYM=4,THICK=2,SYMSIZE=2
!P.MULTI       = 0


;;  k_12 at max variance is not correct on plot but k_13 and k_14 seem okay --> ???


STOP
;;
;;
;;  Finish writing routine
;;
;;






















END


;ydat           = phiby12/(mag__vec(dr_12_all,/NAN))[0]/ABS(costhkr_p1_12[0])
;ydt2           = phiby13/(mag__vec(dr_13_all,/NAN))[0]/ABS(costhkr_p1_13[0])
;ydt3           = phiby14/(mag__vec(dr_14_all,/NAN))[0]/ABS(costhkr_p1_14[0])
;xdat           = [fft_freq_1,fft_freq_1]
;ydat           = MEAN([[[kmag_zp1_12]],[[kmag_zm1_12]]],/NAN,DIMENSION=3)
;ydt2           = MEAN([[[kmag_zp1_13]],[[kmag_zm1_13]]],/NAN,DIMENSION=3)
;ydt3           = MEAN([[[kmag_zp1_14]],[[kmag_zm1_14]]],/NAN,DIMENSION=3)
;ydat           = [kmag_zp1_12,kmag_zm1_12]
;ydt2           = [kmag_zp1_13,kmag_zm1_13]
;ydt3           = [kmag_zp1_14,kmag_zm1_14]
;zdat           = [cvfbz12,cvfbz12]
;zdt2           = [cvfbz13,cvfbz13]
;zdt3           = [cvfbz14,cvfbz14]
;ydat           = kmag_yp1_12
;ydt2           = kmag_zp1_13
;ydt3           = kmag_yp1_14
;zdat           = cvfby12
;zdt2           = cvfbz13
;zdt3           = cvfby14
